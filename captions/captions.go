package captions

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

type CaptionsHandler interface {
	CaptionsFromXml(filepath string, typ CaptionsType)
}

type CaptionsClient struct {
}

func NewCaptionsClient() *CaptionsClient {
	return &CaptionsClient{}
}

func (c *CaptionsClient) CaptionsFrom(url string, CaptionsType CaptionsType) (string, error) {

	// Fetch the captions file from the URL
	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("error fetching URL: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("received non-200 response code: %d", resp.StatusCode)
	}

	// Read the content into memory
	byteValue, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("error reading response body: %v", err)
	}

	var captions Captions
	err = json.Unmarshal(byteValue, &captions)
	if err != nil {
		return "", fmt.Errorf("error unmarshalling JSON: %v", err)
	}

	header := `[Script Info]
; Script generated by XML to ASS converter
Title: Converted Subtitles
ScriptType: v4.00+
Collisions: Normal
PlayDepth: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,24,&H00FFFFFF,&H00FFFF00,&H00000000,&H64000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`
	switch CaptionsType {
	case CaptionsSingleWord:
		return header + "\n" + singleWordCaptionsFrom(captions), nil
	case CaptionsHormozi:
		return hormoziCaptionsFrom(captions), nil
		// case CaptionsBackgroundColor:
		// 	return header + "\n" + backgroundColorCaptionsFrom(captions), nil
	}

	return "", fmt.Errorf("invalid caption type")
}

func singleWordCaptionsFrom(captions Captions) string {
	ret := ""

	for i, event := range captions.Events {
		if event.Segs == nil || len(event.Segs) == 1 && event.Segs[0].UTF8 == "\n" {
			continue
		}

		for j, s := range event.Segs {
			var endTime int

			if j == len(event.Segs)-1 {
				if i == len(captions.Events)-1 {
					endTime = event.TStartMs + event.DDurationMs
				} else {
					endTime = captions.Events[i+1].TStartMs - 1
				}
			} else {
				endTime = event.TStartMs + event.Segs[j+1].TOffsetMs - 1
			}

			dialogue := fmt.Sprintf("Dialogue: 0,%s,%s,Default,,0,0,0,,", msToASSTime(event.TStartMs+s.TOffsetMs), msToASSTime(endTime))
			dialogue += strings.TrimSpace(s.UTF8)

			ret += dialogue + "\n"
		}
	}

	return ret
}

func hormoziCaptionsFrom(captions Captions) string {
	header := `[Script Info]
; Script generated by XML to ASS converter
Title: Converted Subtitles
ScriptType: v4.00+
Collisions: Normal
PlayDepth: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,The Bold Font,24,&H00FFFFFF,&H0033FF33,&H00000000,&H64000000,-1,0,0,0,100,100,0,0,1,3,5,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text`

	ret := ""

	for i, event := range captions.Events {
		if event.Segs == nil || len(event.Segs) == 1 && event.Segs[0].UTF8 == "\n" {
			continue
		}

		for j, s := range event.Segs {
			var endTime int

			if j == len(event.Segs)-1 {
				if i == len(captions.Events)-1 {
					endTime = event.TStartMs + event.DDurationMs
				} else {
					endTime = captions.Events[i+1].TStartMs - 1
				}
			} else {
				endTime = event.TStartMs + event.Segs[j+1].TOffsetMs - 1
			}

			dialogue := fmt.Sprintf("Dialogue: 0,%s,%s,Default,,0,0,0,,", msToASSTime(event.TStartMs+s.TOffsetMs), msToASSTime(endTime))
			for k, seg := range event.Segs {
				if k == j {
					dialogue += " " + "{\\c&H0033FF33}" + strings.TrimSpace(seg.UTF8) + "{\\c&HFFFFFF&}"
				} else {
					dialogue += " " + strings.TrimSpace(seg.UTF8)
				}
			}

			ret += dialogue + "\n"
		}
	}

	return header + "\n" + ret
}

func msToASSTime(ms int) string {
	h := ms / 3600000
	m := (ms % 3600000) / 60000
	s := (ms % 60000) / 1000
	cs := (ms % 1000) / 10
	return fmt.Sprintf("%d:%02d:%02d.%02d", h, m, s, cs)
}
